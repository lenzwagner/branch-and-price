import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np
import os

# Output directory for TeX files
TEX_OUTPUT_DIR = os.path.join(os.path.dirname(__file__), '..', 'plots', 'results')


def _print_tex(fig, caption="Plot", label="fig:plot", save_to_file=True):
    """
    Helper to save plots as PDF and SVG for LaTeX documents.
    Exports both formats for maximum flexibility in Overleaf.

    Args:
        fig: matplotlib figure object
        caption: Caption for the figure
        label: LaTeX label (also used for filename)
        save_to_file: If True, saves to TEX_OUTPUT_DIR; if False, only prints
    """
    try:
        # Ensure output directory exists
        os.makedirs(TEX_OUTPUT_DIR, exist_ok=True)
        basename = label.replace("fig:", "")

        # File paths
        pdf_filepath = os.path.join(TEX_OUTPUT_DIR, f"{basename}.pdf")
        svg_filepath = os.path.join(TEX_OUTPUT_DIR, f"{basename}.svg")
        tex_filepath = os.path.join(TEX_OUTPUT_DIR, f"{basename}.tex")

        # Save as PDF (for LaTeX/Overleaf)
        fig.savefig(pdf_filepath, format='pdf', bbox_inches='tight', dpi=300)

        # Save as SVG (alternative vector format)
        fig.savefig(svg_filepath, format='svg', bbox_inches='tight')

        # Create LaTeX wrapper file
        tex_content = f"""% LaTeX Code for {caption}
% Include with: \\input{{{basename}.tex}}
\\begin{{figure}}[htbp]
  \\centering
  \\includegraphics[width=0.8\\textwidth]{{{basename}.pdf}}
  \\caption{{{caption}}}
  \\label{{{label}}}
\\end{{figure}}
"""

        if save_to_file:
            with open(tex_filepath, 'w') as f:
                f.write(tex_content)
            print(f"✓ PDF saved to: {pdf_filepath}")
            print(f"✓ SVG saved to: {svg_filepath}")
            print(f"✓ TeX wrapper saved to: {tex_filepath}")
        else:
            print("\n" + "%" * 40)
            print(tex_content)
            print("%" * 40 + "\n")

    except Exception as e:
        print(f"\n[Error] Could not generate plot files: {e}\n")


def los_initial_plot(data_dict, normalize_by_focus=False, print_tex=False):
    """
    Creates a split violin plot with dots for Length of Stay data.

    Args:
        data_dict: Dictionary with result data (as generated by loop_main.py)
        normalize_by_focus: If True, divides sum_focus_los by D_focus
        print_tex: If True, prints the LaTeX figure environment code
    """
    # Convert dictionary to DataFrame
    df = pd.DataFrame(data_dict)

    # Ensure sum_focus_los is numeric (handle potential malformed data)
    if 'sum_focus_los' in df.columns:
        df['sum_focus_los'] = pd.to_numeric(df['sum_focus_los'], errors='coerce')

    # ==========================================
    # DATA CLEANING & PREPARATION
    # ==========================================

    # Optional: Normalize
    y_col = "sum_focus_los"
    y_label = " Length of Stay (Days)"

    if normalize_by_focus:
        # Check column name (D_focus or D_focus_count)
        if 'D_focus' in df.columns:
            d_col = 'D_focus'
        elif 'D_focus_count' in df.columns:
            d_col = 'D_focus_count'
        else:
            print("Warning: Neither 'D_focus' nor 'D_focus_count' found. Skipping normalization.")
            d_col = None

        if d_col:
            # Ensure D_focus is numeric
            df[d_col] = pd.to_numeric(df[d_col], errors='coerce')
            # Create normalized column
            df['normalized_los'] = df['sum_focus_los'] / df[d_col]
            y_col = "normalized_los"
            y_label = r'Avg. Length of Stay $\bar{F}_i$ in Days'

    # A. Mapping for OnlyHuman (1 = HOM (Baseline), 0 = HYB (AI-Hybrid))
    df['Service_Model'] = df['OnlyHuman'].map({1: 'HOM (Baseline)', 0: 'HYB (AI-Hybrid)'})

    # B. Mapping for pttr (clean labels)
    pttr_mapping = {
        'light': 'Light',
        'mp': 'Medium',
        'medium': 'Medium',
        'heavy': 'Heavy'
    }
    df['pttr_clean'] = df['pttr'].map(pttr_mapping).fillna(df['pttr'])

    # C. Order for X-axis
    pttr_order = ['Light', 'Medium', 'Heavy']

    # ==========================================
    # PLOTTING (FACET GRID BY T & D)
    # ==========================================
    g = sns.catplot(
        data=df,
        kind="box",
        x="pttr_clean",
        y=y_col,
        hue="Service_Model",
        col="T",
        row="D",
        order=pttr_order,
        hue_order=['HYB (AI-Hybrid)', 'HOM (Baseline)'],
        palette=['#0C7BDC', '#FFC20A'],  # Blue (HYB) / Yellow (HOM)
        height=4,
        aspect=1.2,
        sharey=False,
        legend=False,
        showmeans=True,  # Show mean markers
        showfliers=True,  # Show outliers
        meanprops=dict(marker='D', markerfacecolor='darkgreen',
                       markeredgecolor='darkgreen', markersize=6)
    )

    g.set_axis_labels("Patient-to-Therapist Ratio", y_label)
    g.set_titles("")

    # Center X-axis labels under boxplot groups
    for ax in g.axes.flat:
        ax.set_xticks([0, 1, 2])
        ax.set_xticklabels(pttr_order)

    # Manually create legend to avoid duplicates
    from matplotlib.patches import Patch
    legend_elements = [
        Patch(facecolor='#0C7BDC', edgecolor='white', label='HYB (AI-Hybrid)'),
        Patch(facecolor='#FFC20A', edgecolor='white', label='HOM (Baseline)')
    ]
    g.figure.legend(handles=legend_elements,
                    loc='center left', bbox_to_anchor=(0.85, 0.5),
                    ncol=1,
                    frameon=True)

    plt.tight_layout()
    g.figure.subplots_adjust(right=0.8, wspace=0.3)

    if print_tex:
        _print_tex(g.figure, caption="LOS Initial Plot", label="fig:los_initial")

        # Export CSV data with boxplot statistics
        try:
            csv_df = df[['Service_Model', 'pttr_clean', y_col]].copy()
            csv_df['series'] = csv_df['Service_Model'].map({'HOM (Baseline)': 'HOM', 'HYB (AI-Hybrid)': 'HYB'})
            csv_df.rename(columns={'pttr_clean': 'category', y_col: 'value'}, inplace=True)
            csv_df = csv_df[['series', 'category', 'value']].dropna()

            # Map categories to numeric IDs
            cat_mapping = {'Light': 1, 'Medium': 2, 'Heavy': 3}
            # Add missing values for missing categories if needed by generating the structure first

            stats_list = []
            for series in ['HOM', 'HYB']:
                for category in pttr_order:
                    subset = csv_df[(csv_df['series'] == series) & (csv_df['category'] == category)]['value']

                    if not subset.empty:
                        q1 = subset.quantile(0.25)
                        median = subset.median()
                        q3 = subset.quantile(0.75)
                        iqr = q3 - q1
                        mean_val = subset.mean()

                        # Whiskers usually 1.5 * IQR or min/max within that range
                        whisker_low = max(subset.min(), q1 - 1.5 * iqr)
                        whisker_high = min(subset.max(), q3 + 1.5 * iqr)

                        stats_list.append({
                            'series': series,
                            'category': category,
                            'cat_id': cat_mapping.get(category, 0),
                            'q1': round(q1, 4),
                            'median': round(median, 4),
                            'q3': round(q3, 4),
                            'whisker_low': round(whisker_low, 4),
                            'whisker_high': round(whisker_high, 4),
                            'mean': round(mean_val, 4)
                        })

            stats_df = pd.DataFrame(stats_list)

            csv_path = os.path.join(TEX_OUTPUT_DIR, "los_initial_boxplot_data.csv")
            stats_df.to_csv(csv_path, index=False)
            print(f"✓ Boxplot CSV data saved to: {csv_path}")

        except Exception as e:
            print(f"[Error] Could not save Boxplot CSV: {e}")

    return g


def sorted_savings_plot(data_dict, workload='heavy', print_tex=False):
    """
    Creates a line plot of savings (Human LOS - Hybrid LOS) sorted by magnitude.
    Now iterates over all seeds for the workload and picks the one with max std dev.

    Args:
        data_dict: Dictionary with result data
        workload: 'heavy', 'medium', or 'light'
        print_tex: If True, prints the LaTeX figure environment code
    """
    import ast

    # Convert to DataFrame
    df = pd.DataFrame(data_dict)

    # Filter by workload
    subset = df[df['pttr'] == workload].copy()

    if subset.empty:
        print(f"Warning: No data found for workload '{workload}'")
        return None

    # If using 'medium', treat 'mp' as 'medium' just in case
    # (Though logic above is based on exact match of 'pttr')

    # Since we might have multiple iterations or entries, we need to pick pairs.
    # We assume 'seed' + 'OnlyHuman' identifies a unique run.

    if 'focus_los' not in subset.columns:
        print("Warning: 'focus_los' column missing.")
        return None

    # ==========================================
    # SELECT RANDOM VALID SEED
    # ==========================================
    available_seeds = list(subset['seed'].unique())
    if len(available_seeds) == 0:
        print("Warning: No seeds available")
        return None

    # Shuffle seeds to pick a random one
    np.random.shuffle(available_seeds)

    best_seed = None
    savings = []
    patient_ids = []

    def parse_los_dict(los_value):
        """Parse dict string to actual dict."""
        try:
            if isinstance(los_value, dict):
                return los_value
            elif isinstance(los_value, str):
                return ast.literal_eval(los_value)
            else:
                return {}
        except Exception:
            return {}

    print(f"Selecting a random seed from {len(available_seeds)} available...")

    for current_seed in available_seeds:
        # Get rows for this seed
        human_row = subset[(subset['seed'] == current_seed) & (subset['OnlyHuman'] == 1)]
        hybrid_row = subset[(subset['seed'] == current_seed) & (subset['OnlyHuman'] == 0)]

        if human_row.empty or hybrid_row.empty:
            continue

        # Parse dicts
        try:
            human_dict = parse_los_dict(human_row['focus_los'].iloc[0])
            hybrid_dict = parse_los_dict(hybrid_row['focus_los'].iloc[0])

            # Create diff dict (Human - Hybrid for each patient key)
            common_keys = set(human_dict.keys()) & set(hybrid_dict.keys())
            if not common_keys:
                continue

            # Use this seed
            best_seed = current_seed

            # Store data for plotting
            # Structure: (id, diff, old_los, new_los)
            # Sort by savings (diff), then by patient ID as tie-breaker
            sorted_items = sorted([(k, human_dict[k] - hybrid_dict[k], human_dict[k], hybrid_dict[k])
                                   for k in common_keys if (human_dict[k] - hybrid_dict[k]) != 0],
                                  key=lambda x: (x[1], x[0]))

            patient_ids = [item[0] for item in sorted_items]
            savings = [item[1] for item in sorted_items]
            human_los = [item[2] for item in sorted_items]
            hybrid_los = [item[3] for item in sorted_items]

            break  # Stop after finding the first valid random seed

        except Exception as e:
            print(f"Error processing seed {current_seed}: {e}")
            continue

    if best_seed is None:
        print("Warning: No valid seed found with matching Human/Hybrid pairs.")
        return None

    print(f"Selected Seed: {best_seed}")

    seed = best_seed

    # ==========================================
    # PLOTTING
    # ==========================================
    fig, ax = plt.subplots(figsize=(12, 6))

    # Use patient IDs (as strings) for X-axis labels to avoid numeric formatting issues
    x_labels = [str(pid) for pid in patient_ids]
    x_pos = range(len(savings))

    # Plot bars
    bars = ax.bar(x_pos, savings, color='#0C7BDC', alpha=0.8, edgecolor='white')

    # Reference line at 0
    ax.axhline(0, color='red', linestyle='--', linewidth=1)

    workload_label = workload.capitalize() if workload else 'All'
    ax.set_xlabel('Patients (Sorted by Savings)', fontsize=12)
    ax.set_ylabel('Days Saved (Human LOS - Hybrid LOS)', fontsize=12)

    # Remove X-ticks labels as requested (Patient IDs removed)
    ax.set_xticks([])
    ax.set_xticklabels([])

    # Add value labels inside bars with Patient ID above Old / New (horizontally)
    for i, bar in enumerate(bars):
        height = bar.get_height()
        if abs(height) > 0.1:
            label_text = f"ID: {patient_ids[i]}\n\n{human_los[i]} / {hybrid_los[i]}"
            # Center text in bar, displayed horizontally
            ax.text(bar.get_x() + bar.get_width() / 2., height / 2.,
                    label_text,
                    ha='center', va='center', rotation=0, fontsize=8, color='white')

    import matplotlib.ticker as ticker
    # Format y-axis to show integers only
    ax.yaxis.set_major_locator(ticker.MaxNLocator(integer=True))
    ax.grid(True, axis='y', linestyle=':', alpha=0.6)

    plt.tight_layout()

    if print_tex:
        _print_tex(fig, caption=f"Savings Distribution (Seed {seed})", label="fig:savings")

    return fig


# ==========================================
# MAIN (for testing)
# ==========================================
if __name__ == "__main__":
    import glob

    # Results directory (robust to CWD)
    script_dir = os.path.dirname(os.path.abspath(__file__))
    results_dir = os.path.join(script_dir, '..', 'results', 'parameter_study', 'results')

    if not os.path.exists(results_dir):
        print(f"Directory not found: {results_dir}")
        excel_files = []
    else:
        excel_files = glob.glob(os.path.join(results_dir, '*.xlsx'))

    # Filter out temp files (starting with ~$)
    excel_files = [f for f in excel_files if not os.path.basename(f).startswith('~$')]

    if not excel_files:
        print(f"Error: No Excel files found in '{results_dir}'.")
    else:
        # Find the newest file
        newest_excel = max(excel_files, key=os.path.getmtime)
        print(f"Loading newest file: {newest_excel}")

        try:
            df = pd.read_excel(newest_excel)
            print("Data loaded successfully.")
            # Convert DataFrame to dict for function call
            data_dict = df.to_dict('list')

            # Plot 1: LOS Boxplot - save TeX to parameter_study/plots
            los_initial_plot(data_dict, normalize_by_focus=True, print_tex=True)

            # Plot 2: Sorted Savings Distribution - save TeX to parameter_study/plots
            sorted_savings_plot(data_dict, workload='heavy', print_tex=True)

            print("\nTeX files saved to results/parameter_study/plots/")

            # Show plots interactively
            plt.show()

        except Exception as e:
            print(f"Error loading file: {e}")